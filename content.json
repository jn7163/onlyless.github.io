[{"title":"湖北工业大学教务系统查分,查课小程序","date":"2017-10-26T16:00:00.000Z","path":"2017/10/27/Login_hbut/","text":"首先贴下github项目地址 (如果觉得这个程序好，求个star) 运行该小程序需安装requests和bs4库,还需要安装能操作excel的xlwt库 123pip install requestspip install bs4pip install xlwt 现在该程序不能自动识别验证码，需手动在控制台输入验证码，现可免输入验证码即可登陆（需先在github上获取该库，然后使用分支nocode）使用命令即可1git checout nocode 然后输入学号和密码即可查询，作者本人大二，所以现在可支持查询大一两个学期和大二上的成绩，成绩会自动保存在本地。由于课表不好格式化输出，如需查课表，程序会生成一个excel文件，然后直接查看即可 思路首先用requests库模拟登陆学校的教务系统，然后再进入成绩查询的页面，得到该页面的html源码，用BeatufulSoup来解析页面，提取出每门课的学分和成绩用列表来储存，最后格式化输出，并将输出写入文件。我把直接用函数来表示每个步骤，自我感觉思路比较清晰 源码查分小程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import requestsfrom bs4 import BeautifulSoup,elementimport oslogin_url = 'http://run.hbut.edu.cn/Account/LogOn'checkimg = 'http://run.hbut.edu.cn/Account/GetValidateCode'StuGrade = 'http://run.hbut.edu.cn/StuGrade/Index'g_20171 = '?SemesterName=20171&amp;SemesterNameStr=2017学年%20第一学期'g_20162 = '?SemesterName=20162&amp;SemesterNameStr=2016学年%20第二学期'g_20161 = '?SemesterName=20161&amp;SemesterNameStr=2016学年%20第一学期'file = open('grade.txt','w+')session = requests.Session()headers = &#123; 'Referer' : 'http://run.hbut.edu.cn/', \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36\",&#125;#获取登陆验证码def GetValidateCode(): checkcodecontent = session.get(checkimg,headers=headers) with open('checkcode.jpg','wb') as f: f.write(checkcodecontent.content) print('验证码已写入到本地！') os.startfile(\"checkcode.jpg\") checkcode = input(\"请输入验证码：\") payload = &#123; 'Role':'Student', 'UserName': input('请输入账号：'), 'Password': input('请输入密码：'), 'ValidateCode': checkcode &#125; return payload#获取课程成绩页面def getHtmlText(SemesterName,payload): respose = session.post(login_url,headers=headers,data=payload) print('服务器端返回码：',respose.status_code) if SemesterName is '1': SemesterName = g_20161 if SemesterName is '2': SemesterName = g_20162 if SemesterName is '3': SemesterName = g_20171 grade_url = StuGrade+SemesterName stugrade = session.get(grade_url,headers=headers) return stugrade.text #提取各科成绩def GetFromText(txt): form = [] soup = BeautifulSoup(txt,'html.parser') for tr in soup.find('table').children: try: if isinstance(tr,element.Tag): tds = tr('td') Class = tds[1].string #课程 Credit = tds[4].string #学分 Grade = tds[5].string #成绩 form.append([''.join(Class.split()),''.join(Credit.split()),''.join(Grade.split())]) except: continue return form#格式输出各科成绩def printgrade(ulist,num): tplt = \"&#123;0:&#123;3&#125;^25&#125;\\t&#123;1:^10&#125;\\t&#123;2:^10&#125;\\n\" print(tplt.format(\"课程\",\"学分\",\"成绩\",chr(12288))) file.write(tplt.format(\"课程\",\"学分\",\"成绩\",chr(12288))) for i in range(num): u = ulist[i] print(tplt.format(u[0],u[1],u[2],chr(12288))) file.write(tplt.format(u[0],u[1],u[2],chr(12288)))def main(): try: payload = GetValidateCode() print('16学年第一学期： 1') print('16学年第二学期： 2') print('17学年第一学期： 3') SenesterName = input('请输入查询的学期：') txt = getHtmlText(SenesterName,payload) form = GetFromText(txt) printgrade(form,len(form)); except : print(\"Error\") finally: file.close()main() 查课小程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import requestsfrom bs4 import BeautifulSoupimport xlwtimport oslogin_url = 'http://run.hbut.edu.cn/Account/LogOn'checkimg = 'http://run.hbut.edu.cn/Account/GetValidateCode'Schedule = 'http://run.hbut.edu.cn/ArrangeTask/MyselfSchedule'workbook = xlwt.Workbook(encoding='utf-8')worksheet = workbook.add_sheet('MyselfSchedule')session = requests.Session()headers = &#123; 'Referer' : 'http://run.hbut.edu.cn/', \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36\",&#125;#获取登陆验证码def GetValidateCode(): checkcodecontent = session.get(checkimg,headers=headers) with open('checkcode.jpg','wb') as f: f.write(checkcodecontent.content) print('验证码已写入到本地！') os.startfile(\"checkcode.jpg\") checkcode = input(\"请输入验证码：\") payload = &#123; 'Role':'Student', 'UserName': input('请输入账号：'), 'Password': input('请输入密码：'), 'ValidateCode': checkcode &#125; return payload#获取课程表网页def getHtmlText(payload): respose = session.post(login_url,headers=headers,data=payload) print('服务器端返回码：',respose.status_code) work = session.get(Schedule,headers=headers) return work.text#提取网页中的课程表def getFormText(string): soup = BeautifulSoup(string,'html.parser') list = [] for tr in soup.find('table').children: try: time = tr('th')[0].string if time==None: continue day1 = tr('td')[0].string day2 = tr('td')[1].string day3 = tr('td')[2].string day4 = tr('td')[3].string day5 = tr('td')[4].string day6 = tr('td')[5].string day7 = tr('td')[6].string list.append([time,day1,day2,day3,day4,day5,day6,day7]) except: continue return list#将提取到的课程表写入excel表格中def WirteXls(list): worksheet.write(0,1,\"星期一\") worksheet.write(0,2,\"星期二\") worksheet.write(0,3,\"星期三\") worksheet.write(0,4,\"星期四\") worksheet.write(0,5,\"星期五\") worksheet.write(0,6,\"星期六\") worksheet.write(0,7,\"星期日\") for i in range(len(list)): u = list[i] for k in range(8): worksheet.write(i+1,k,u[k])def main(): try: payload = GetValidateCode() string = getHtmlText(payload) string = string.replace('&lt;br /&gt;','') list = getFormText(string) WirteXls(list) finally: workbook.save('MyselfSchedule.xls')main()","link":"","tags":[{"name":"小程序","slug":"小程序","permalink":"http://www.djangoz.com/tags/小程序/"}]},{"title":"统计文本中单词频率","date":"2017-10-17T16:00:00.000Z","path":"2017/10/18/Vocabulary-Statistics/","text":"想起高中的时候英语一直很差，后来发现背英语中出现频率最高的单词是一种很高效的学习方法，于是现在写出来一个小程序 github项目地址(如果觉得这个程序好，求个star)这个小程序可以统计文件input.txt文本中所有英文单词的词频（由高到低排序），并给出每个单词的翻译这个程序有两种方法，第一种用goole-cloud库，收费的，不过运行时间快一些，第二种模拟网页请求，时间略长,不能大量翻译.本程序用的两种方法都可以运行，第一种在本机运行后，超出了免费翻译次数，于是就用的第二种，要用第一种的话，把源代码中注释的代码取消注释即可，再把第二种的注释就可以了 一.运行前需要安装google-cloud库,并安装Google Cloud SDK1.安装相关模块1pip install --upgrade google-cloud-translate 2.调用api进行翻译之前，需要安装相关证书安装 Google Cloud SDK因为在本地上运行，使用的第一种方式，安装之后会有自动弹出验证邮箱的界面，如果没有在Google cloud sdk shell 运行1gcloud auth application-default login 二.使用urllib取googletranslate模拟一个头部，请求到translate.google.com去，然后解析出翻译文本 运行方式把将要统计的文本放入Input.txt文件中，直接运行 1python word.py 即可 源代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#coding=utf8import re# from google.cloud import translate import urllib.requestimport sys# translate_client = translate.Client()# language = 'zh_CN' #将要翻译的语言length = 4 #提选出小于此长度的单词input = open(\"words.txt\",'r',encoding='utf-8')output = open('ouput.txt','w+',encoding='utf-8')typ = sys.getfilesystemencoding()def translate(querystr, to_l=\"zh\", from_l=\"en\"): C_agent = &#123;'User-Agent': \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36\"&#125; flag = 'class=\"t0\"&gt;' tarurl = \"http://translate.google.com/m?hl=%s&amp;sl=%s&amp;q=%s \\ \" % (to_l, from_l, querystr.replace(\" \", \"+\")) request = urllib.request.Request(tarurl, headers=C_agent) page = str(urllib.request.urlopen(request).read().decode(typ)) target = page[page.find(flag) + len(flag):] target = target.split(\"&lt;\")[0] return targettry: all_word = input.read() l = re.split(r'[^A-Za-z]+',all_word) d = &#123;&#125; for i in l: i = i.lower() if d.get(i)==None: d[i] = 1 else: d[i] = d[i] +1 ju = 0 for word in sorted(d,key=d.get,reverse=True): if len(word)&lt;length: continue # translation = translate_client.translate(word,target_language=language) # tran = translation['translatedText'] tran = translate(word) string = \"%-18s%-10s%-7d\\t\"%(word,tran,d[word]) # string = \"%-20s%-7d\\t\" %(word,d[word]) ju += 1 if ju%8==0: string += '\\n' output.write(string)finally: input.close() output.close()","link":"","tags":[{"name":"小程序","slug":"小程序","permalink":"http://www.djangoz.com/tags/小程序/"}]},{"title":"可识别括号优先级的简易计算器","date":"2017-09-29T16:00:00.000Z","path":"2017/09/30/simple-calculator/","text":"github项目地址该计算器用java实现更新：现已支持多位数的输入（利用正则表达式提取输入的数值，再压入数值栈中）GUI用swing实现，可识别括号优先级是用了双栈，一个栈存取操作符，一个栈存取数据界面巨丑，待我学到更多后来更新此计算器。主要是拿来练手的（这是第一个自己用代码实现GUI的小程序！！！）主界面: CalculatorFrame.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;/*计算器框架*/public class CalculatorFrame &#123; private JFrame frame; private JTextField number; private JPanel panel; private static String expression =\"\"; //输入的数据转划为字符串 public CalculatorFrame()&#123; frame = new JFrame(\"Calculator\"); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setSize(300,300); frame.setLocationRelativeTo(null); number = new JTextField(); number.setEditable(false); frame.add(number,BorderLayout.NORTH); panel = new JPanel(); panel.setLayout(new GridLayout(6,3)); frame.add(panel,BorderLayout.CENTER); for(int i =1;i&lt;10;i++)&#123; addButton(String.valueOf(i)); &#125; addButton(\"+\"); addButton(\"0\"); addButton(\"-\"); addButton(\"*\"); addButton(\"C\"); //按钮C的作用是清空整个输入 addButton(\"/\"); addButton(\"(\"); addButton(\")\"); JButton equal = new JButton(\"=\"); equal.setActionCommand(\"=\"); equal.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e)&#123; number.setText(\"\"+new Calculate().calculating(expression)); //显示计算得到的结果 expression = \"\"; // 计算后整个输入清空 &#125; &#125;); panel.add(equal); frame.add(panel); frame.setResizable(false); //设置窗口大小不可改变 frame.setVisible(true); &#125; /*当不为输入不为“C”和“=”时，将输入转化为字符串,为“C”时清空输入*/ private void addButton(String name )&#123; JButton temp = new JButton(name); temp.setActionCommand(name); if(!\"C\".equals(name)) temp.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; expression += name; number.setText(expression); &#125; &#125;); else temp.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; expression=\"\"; &#125; &#125;); panel.add(temp); &#125;&#125; Calculate.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.Stack;/*读取一个字符串，然后在两个栈中计算表达式的值,这样可以判断（）的优先级*/public class Calculate &#123; private static Stack&lt;String&gt; ops = new Stack&lt;&gt;(); //操作栈 private static Stack&lt;Double&gt; nums = new Stack&lt;&gt;(); //数据栈 private static void calculate() &#123; String op = ops.pop(); if (op.equals(\"+\")) nums.push(nums.pop() + nums.pop()); else if (op.equals(\"-\")) nums.push(-(nums.pop() - nums.pop()); else if (op.equals(\"*\")) nums.push(nums.pop() * nums.pop()); else if (op.equals(\"/\")) nums.push(nums.pop() / nums.pop()); &#125; public double calculating(String s)&#123; String[] strs = s.split(\"[^0-9]+\"); //利用正则表达式提取输入中的数值 for(String str:strs)&#123; nums.push(Double.parseDouble(str)); //将提取的数值压到栈中 &#125; for (int i = 0; i &lt; s.length(); i++) &#123; switch (s.charAt(i)) &#123; case '(': break; case '+': ops.push(\"+\"); break; case '-': ops.push(\"-\"); break; case '*': ops.push(\"*\"); break; case '/': ops.push(\"/\"); break; case ')': &#123; calculate(); break; &#125; default: //nums.push(Double.parseDouble(s.charAt(i) + \"\")); break; &#125; &#125; while (!ops.empty()) &#123; calculate(); &#125; return nums.pop(); //返回结果 &#125;&#125; run.java123456789101112import java.awt.*;public class run &#123; public static void main(String[] args)&#123; EventQueue.invokeLater(new Runnable() &#123; @Override public void run() &#123; new CalculatorFrame(); &#125; &#125;); &#125;&#125;","link":"","tags":[{"name":"小程序","slug":"小程序","permalink":"http://www.djangoz.com/tags/小程序/"}]},{"title":"Windows cmd使用常用bash命令","date":"2017-09-27T16:00:00.000Z","path":"2017/09/28/windows_use_bash/","text":"windows的cmd命令用起来不顺手，Linux系的bash命令酸爽多了。首先下载git，一般来说都有这个软件，有的话忽略。然后找到git的安装路径，我电脑git安装在D盘的然后进入usr目录，再进入bin目录，把该目录链接添加一个环境变量。保存就可以了然后就可以愉快的使用bash命令了，瞬间酸爽许多。ls rm mkdir等等都可以完美使用.最主要的是可以使用vim，让cmd瞬间强大了许多,有木有!!!","link":"","tags":[{"name":"技巧","slug":"技巧","permalink":"http://www.djangoz.com/tags/技巧/"}]},{"title":"并查集(Union-Find)算法介绍","date":"2017-09-11T16:00:00.000Z","path":"2017/09/12/union-find/","text":"在看完algorithms-part1第一周的Union-Find视频和算法(第四版) 一书的Section 1.5后，本来也打算写一些笔记的，但是发现有篇文章写得很好，就转载过来了。先贴上自己学习过程中写的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//import edu.princeton.cs.introcs.StdIn;import java.util.Scanner;public class UnionFind &#123; private int[] id; private int[] sz; private int count; public UnionFind(int N) &#123; count = 0; id = new int[N]; sz = new int[N]; for (int i = 0; i &lt; N; i++) &#123; id[i] = i; &#125; for (int i = 0; i &lt; N; i++) &#123; sz[i] = 1; &#125; &#125; public int count() &#123; return count; &#125; private int find(int i) &#123; while (i != id[i]) &#123; id[i] = id[id[i]]; //路径压缩 i = id[i]; &#125; return i; &#125; public boolean connected(int p, int q) &#123; return find(p) == find(q); &#125; public void union(int p, int q) &#123; int i = find(p); int j = find(q); if (i == j) return; if (sz[i] &lt; sz[j]) &#123; //对树的高度加权，总是选择讲小树连接到大树 id[i] = j; sz[j] += sz[i]; &#125; else &#123; id[j] = i; sz[i] += sz[j]; &#125; count++; &#125; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); // int N = StdIn.readInt(); int N = in.nextInt(); UnionFind uFind = new UnionFind(N); while (in.hasNext()) &#123; // int p = StdIn.readInt(); // int q = StdIn.readInt(); int p = in.nextInt(); int q = in.nextInt(); if (uFind.connected(p, q)) continue; uFind.union(p, q); System.out.println(p + \" \" + q); &#125; System.out.println(uFind.count + \"components\"); &#125;&#125; 本文主要介绍解决动态连通性一类问题的一种算法，使用到了一种叫做并查集的数据结构，称为Union-Find。更多的信息可以参考算法(第四版) 一书的Section 1.5，实际上本文也就是基于它的一篇读后感吧。原文中更多的是给出一些结论，我尝试给出一些思路上的过程，即为什么要使用这个方法，而不是别的什么方法。我觉得这个可能更加有意义一些，相比于记下一些结论。 关于动态连通性我们看一张图来了解一下什么是动态连通性：假设我们输入了一组整数对，即上图中的(4, 3) (3, 8)等等，每对整数代表这两个points/sites是连通的。那么随着数据的不断输入，整个图的连通性也会发生变化，从上图中可以很清晰的发现这一点。同时，对于已经处于连通状态的points/sites，直接忽略，比如上图中的(8, 9)。 动态连通性的应用场景： 网络连接判断： 如果每个pair中的两个整数分别代表一个网络节点，那么该pair就是用来表示这两个节点是需要连通的。那么为所有的pairs建立了动态连通图后，就能够尽可能少的减少布线的需要，因为已经连通的两个节点会被直接忽略掉。 变量名等同性(类似于指针的概念)： 在程序中，可以声明多个引用来指向同一对象，这个时候就可以通过为程序中声明的引用和实际对象建立动态连通图来判断哪些引用实际上是指向同一对象。 对问题建模：在对问题进行建模的时候，我们应该尽量想清楚需要解决的问题是什么。因为模型中选择的数据结构和算法显然会根据问题的不同而不同，就动态连通性这个场景而言，我们需要解决的问题可能是： 给出两个节点，判断它们是否连通，如果连通，不需要给出具体的路径 给出两个节点，判断它们是否连通，如果连通，需要给出具体的路径 就上面两种问题而言，虽然只有是否能够给出具体路径的区别，但是这个区别导致了选择算法的不同，本文主要介绍的是第一种情况，即不需要给出具体路径的Union-Find算法，而第二种情况可以使用基于DFS的算法。 建模思路：最简单而直观的假设是，对于连通的所有节点，我们可以认为它们属于一个组，因此不连通的节点必然就属于不同的组。随着Pair的输入，我们需要首先判断输入的两个节点是否连通。如何判断呢？按照上面的假设，我们可以通过判断它们属于的组，然后看看这两个组是否相同，如果相同，那么这两个节点连通，反之不连通。为简单起见，我们将所有的节点以整数表示，即对N个节点使用0到N-1的整数表示。而在处理输入的Pair之前，每个节点必然都是孤立的，即他们分属于不同的组，可以使用数组来表示这一层关系，数组的index是节点的整数表示，而相应的值就是该节点的组号了。该数组可以初始化为： 12for(int i = 0; i &lt; size; i++) id[i] = i; 即对于节点i，它的组号也是i。 初始化完毕之后，对该动态连通图有几种可能的操作： 查询节点属于的组 数组对应位置的值即为组号 判断两个节点是否属于同一个组 分别得到两个节点的组号，然后判断组号是否相等 连接两个节点，使之属于同一个组 分别得到两个节点的组号，组号相同时操作结束，不同时，将其中的一个节点的组号换成另一个节点的组号 获取组的数目 初始化为节点的数目，然后每次成功连接两个节点之后，递减1 API我们可以设计相应的API：注意其中使用整数来表示节点，如果需要使用其他的数据类型表示节点，比如使用字符串，那么可以用哈希表来进行映射，即将String映射成这里需要的Integer类型。 分析以上的API，方法connected和union都依赖于find，connected对两个参数调用两次find方法，而union在真正执行union之前也需要判断是否连通，这又是两次调用find方法。因此我们需要把find方法的实现设计的尽可能的高效。所以就有了下面的Quick-Find实现。 Quick-Find 算法：12345678910111213141516171819202122232425262728293031public class UF &#123; private int[] id; // access to component id (site indexed) private int count; // number of components public UF(int N) &#123; // Initialize component id array. count = N; id = new int[N]; for (int i = 0; i &lt; N; i++) id[i] = i; &#125; public int count() &#123; return count; &#125; public boolean connected(int p, int q) &#123; return find(p) == find(q); &#125; public int find(int p) &#123; return id[p]; &#125; public void union(int p, int q) &#123; // 获得p和q的组号 int pID = find(p); int qID = find(q); // 如果两个组号相等，直接返回 if (pID == qID) return; // 遍历一次，改变组号使他们属于一个组 for (int i = 0; i &lt; id.length; i++) if (id[i] == pID) id[i] = qID; count--; &#125; &#125; 举个例子，比如输入的Pair是(5， 9)，那么首先通过find方法发现它们的组号并不相同，然后在union的时候通过一次遍历，将组号1都改成8。当然，由8改成1也是可以的，保证操作时都使用一种规则就行。上述代码的find方法十分高效，因为仅仅需要一次数组读取操作就能够找到该节点的组号，但是问题随之而来，对于需要添加新路径的情况，就涉及到对于组号的修改，因为并不能确定哪些节点的组号需要被修改，因此就必须对整个数组进行遍历，找到需要修改的节点，逐一修改，这一下每次添加新路径带来的复杂度就是线性关系了，如果要添加的新路径的数量是M，节点数量是N，那么最后的时间复杂度就是MN，显然是一个平方阶的复杂度，对于大规模的数据而言，平方阶的算法是存在问题的，这种情况下，每次添加新路径就是“牵一发而动全身”，想要解决这个问题，关键就是要提高union方法的效率，让它不再需要遍历整个数组。 Quick-Union 算法：考虑一下，为什么以上的解法会造成“牵一发而动全身”？因为每个节点所属的组号都是单独记录，各自为政的，没有将它们以更好的方式组织起来，当涉及到修改的时候，除了逐一通知、修改，别无他法。所以现在的问题就变成了，如何将节点以更好的方式组织起来，组织的方式有很多种，但是最直观的还是将组号相同的节点组织在一起，想想所学的数据结构，什么样子的数据结构能够将一些节点给组织起来？常见的就是链表，图，树，什么的了。但是哪种结构对于查找和修改的效率最高？毫无疑问是树，因此考虑如何将节点和组的关系以树的形式表现出来。 如果不改变底层数据结构，即不改变使用数组的表示方法的话。可以采用parent-link的方式将节点组织起来，举例而言，id[p]的值就是p节点的父节点的序号，如果p是树根的话，id[p]的值就是p，因此最后经过若干次查找，一个节点总是能够找到它的根节点，即满足id[root] = root的节点也就是组的根节点了，然后就可以使用根节点的序号来表示组号。所以在处理一个pair的时候，将首先找到pair中每一个节点的组号(即它们所在树的根节点的序号)，如果属于不同的组的话，就将其中一个根节点的父节点设置为另外一个根节点，相当于将一颗独立的树编程另一颗独立的树的子树。直观的过程如下图所示。但是这个时候又引入了问题。 在实现上，和之前的Quick-Find只有find和union两个方法有所不同：12345678910111213141516private int find(int p) &#123; // 寻找p节点所在组的根节点，根节点具有性质id[root] = root while (p != id[p]) p = id[p]; return p; &#125; public void union(int p, int q) &#123; // Give p and q the same root. int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) return; id[pRoot] = qRoot; // 将一颗树(即一个组)变成另外一课树(即一个组)的子树 count--; &#125; 树这种数据结构容易出现极端情况，因为在建树的过程中，树的最终形态严重依赖于输入数据本身的性质，比如数据是否排序，是否随机分布等等。比如在输入数据是有序的情况下，构造的BST会退化成一个链表。在我们这个问题中，也是会出现的极端情况的，如下图所示。 为了克服这个问题，BST可以演变成为红黑树或者AVL树等等。 然而，在我们考虑的这个应用场景中，每对节点之间是不具备可比性的。因此需要想其它的办法。在没有什么思路的时候，多看看相应的代码可能会有一些启发，考虑一下Quick-Union算法中的union方法实现：12345678910public void union(int p, int q) &#123; // Give p and q the same root. int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) return; id[pRoot] = qRoot; // 将一颗树(即一个组)变成另外一课树(即一个组)的子树 count--; &#125; 上面 id[pRoot] = qRoot 这行代码看上去似乎不太对劲。因为这也属于一种“硬编码”，这样实现是基于一个约定，即p所在的树总是会被作为q所在树的子树，从而实现两颗独立的树的融合。那么这样的约定是不是总是合理的呢？显然不是，比如p所在的树的规模比q所在的树的规模大的多时，p和q结合之后形成的树就是十分不和谐的一头轻一头重的”畸形树“了。所以我们应该考虑树的大小，然后再来决定到底是调用：id[pRoot] = qRoot 或者是 id[qRoot] = pRoot即总是size小的树作为子树和size大的树进行合并。这样就能够尽量的保持整棵树的平衡。 所以现在的问题就变成了：树的大小该如何确定？我们回到最初的情形，即每个节点最一开始都是属于一个独立的组，通过下面的代码进行初始化：12for (int i = 0; i &lt; N; i++) id[i] = i; // 每个节点的组号就是该节点的序号 以此类推，在初始情况下，每个组的大小都是1，因为只含有一个节点，所以我们可以使用额外的一个数组来维护每个组的大小，对该数组的初始化也很直观：12345678910public void union(int p, int q) &#123; int i = find(p); int j = find(q); if (i == j) return; // 将小树作为大树的子树 if (sz[i] &lt; sz[j]) &#123; id[i] = j; sz[j] += sz[i]; &#125; else &#123; id[j] = i; sz[i] += sz[j]; &#125; count--; &#125; Quick-Union 和 Weighted Quick-Union 的比较：可以发现，通过sz数组决定如何对两棵树进行合并之后，最后得到的树的高度大幅度减小了。这是十分有意义的，因为在Quick-Union算法中的任何操作，都不可避免的需要调用find方法，而该方法的执行效率依赖于树的高度。树的高度减小了，find方法的效率就增加了，从而也就增加了整个Quick-Union算法的效率。 上图其实还可以给我们一些启示，即对于Quick-Union算法而言，节点组织的理想情况应该是一颗十分扁平的树，所有的孩子节点应该都在height为1的地方，即所有的孩子都直接连接到根节点。这样的组织结构能够保证find操作的最高效率。 那么如何构造这种理想结构呢？在find方法的执行过程中，不是需要进行一个while循环找到根节点嘛？如果保存所有路过的中间节点到一个数组中，然后在while循环结束之后，将这些中间节点的父节点指向根节点，不就行了么？但是这个方法也有问题，因为find操作的频繁性，会造成频繁生成中间节点数组，相应的分配销毁的时间自然就上升了。那么有没有更好的方法呢？还是有的，即将节点的父节点指向该节点的爷爷节点，这一点很巧妙，十分方便且有效，相当于在寻找根节点的同时，对路径进行了压缩，使整个树结构扁平化。相应的实现如下，实际上只需要添加一行代码：12345678910private int find(int p) &#123; while (p != id[p]) &#123; // 将p节点的父节点设置为它的爷爷节点 id[p] = id[id[p]]; p = id[p]; &#125; return p; &#125; 至此，动态连通性相关的Union-Find算法基本上就介绍完了，从容易想到的Quick-Find到相对复杂但是更加高效的Quick-Union，然后到对Quick-Union的几项改进，让我们的算法的效率不断的提高。这几种算法的时间复杂度如下所示：对大规模数据进行处理，使用平方阶的算法是不合适的，比如简单直观的Quick-Find算法，通过发现问题的更多特点，找到合适的数据结构，然后有针对性的进行改进，得到了Quick-Union算法及其多种改进算法，最终使得算法的复杂度降低到了近乎线性复杂度。 如果需要的功能不仅仅是检测两个节点是否连通，还需要在连通时得到具体的路径，那么就需要用到别的算法了，比如DFS或者BFS。 该文章转载于dm_vincent的专栏","link":"","tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://www.djangoz.com/tags/算法与数据结构/"}]},{"title":"java实现简易的queue","date":"2017-09-08T16:00:00.000Z","path":"2017/09/09/queue-in-java/","text":"用java实现queue模板队列是一种基于先进先出（FIFO)策略的线性数据结构。这就像在学校食堂买饭排队一样，排在前面的人先打饭，后面的人后打饭。该模板只有6个方法，分别是isEmpty(),size(),front(),back(),pop(),push(T).代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class queue&lt;Item&gt; &#123; private Node first; private Node last; private int N; private class Node &#123; Item item; Node next; &#125; public boolean isEmpty()&#123; //判断是否为空 return this.first==null; &#125; public int size()&#123; //队列的大小 return N; &#125; public void push(Item T)&#123; //向队列添加元素 Node temp = last; last = new Node(); last.item = T; last.next = null; if(isEmpty()) first = last; else temp.next = last; N++; &#125; public Item pop()&#123; //弹出第一个元素，并返回第一个元素 Node temp = first; first = first.next; if(isEmpty()) last=null; N--; return temp.item; &#125; public Item front()&#123; //访问队列第一个元素 return first.item; &#125; public Item back()&#123;&#125; //访问队列最后一个元素 public static void main(String[] args) &#123; queue&lt;String&gt; sb = new queue&lt;String&gt;(); sb.push(\"hi\"); if(sb.isEmpty()) System.out.println(\"isEmpty!\"); else System.out.println(\"NotEmpty!\"); sb.push(\"hello\"); sb.push(\"world\"); System.out.println(sb.front()); System.out.println(sb.pop()); System.out.println(sb.back()); System.out.println(sb.pop()); System.out.println(sb.pop()); if(sb.isEmpty()) System.out.println(\"isEmpty!\"); else System.out.println(\"NotEmpty!\"); &#125;&#125; 该程序输入为1234567NotEmpty!hihiworldhelloworldNotEmpty! 部分实现参考于算法(第四版)","link":"","tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://www.djangoz.com/tags/算法与数据结构/"}]},{"title":"java实现简易的stack","date":"2017-09-08T16:00:00.000Z","path":"2017/09/09/stack-in-java/","text":"用java实现stack模板栈是一种基于后进先出（LIFO)策略的线性数据结构。这就像手枪弹夹一样，先填进去的子弹都打出，后填进去的子弹后打出。该模板只有5个方法，分别是isEmpty(),size(),top(),pop(),push(T).代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class stack&lt;Item&gt; &#123; private Node first; private int N; private class Node&#123; Item item; Node next; &#125; public boolean isEmpty()&#123; //判断是否为空 return first ==null; &#125; public int size()&#123; //栈的大小 return N; &#125; public void push(Item item)&#123; //添加元素 Node oldfirst = first; first = new Node(); first.item = item; first.next = oldfirst; N++; &#125; public Item pop()&#123; //弹出元素 Item item = first.item; first = first.next; N--; return item; &#125; public Item top()&#123; //访问栈顶元素 return first.item; &#125; public static void main(String[] args) &#123; stack&lt;Integer&gt; te = new stack&lt;Integer&gt;(); te.push(19); if(te.isEmpty())&#123; System.out.println(\"isEmpty!\"); &#125;else System.out.println(\"Not Empty!\"); te.push(20); System.out.println(te.pop()); System.out.println(te.top()); System.out.println(te.pop()); if(te.isEmpty())&#123; System.out.println(\"isEmpty!\"); &#125;else System.out.println(\"Not Empty!\"); &#125;&#125; 该程序输入为：12345Not Empty!201919isEmpty! 部分实现参考于算法(第四版)","link":"","tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://www.djangoz.com/tags/算法与数据结构/"}]},{"title":"windows下访问linux分区文件","date":"2017-08-18T03:27:50.000Z","path":"2017/08/18/windows-to-linux/","text":"Ext2Fsd Project是Windows下的应用程序，可以在windows下访问ext2/ext3/ext4文件系统，可以设置编码，分配盘符，更可以在windows下读写，使用性能好。","link":"","tags":[{"name":"linux","slug":"linux","permalink":"http://www.djangoz.com/tags/linux/"}]},{"title":"更换主题","date":"2017-08-17T10:10:16.000Z","path":"2017/08/17/change-theme/","text":"爱折腾的我又把原来网站换了框架，把jekyll换成了hexo，感觉hexo支持的主题看起来美观多了该主题来自indigo","link":"","tags":[{"name":"闲言碎语","slug":"闲言碎语","permalink":"http://www.djangoz.com/tags/闲言碎语/"}]},{"title":"在linux环境安装shadowsocksR客户端","date":"2017-08-15T16:00:00.000Z","path":"2017/08/16/linux_setup_ssr/","text":"ssr 相比于ss 更加稳定，推荐安装ssr之前在网上找很久没找到如何在Linux环境下运行ssr，后来通过这个脚本安装ssr，亲测可用安装以后可通过 ssr start或者 ssr config 命令运行ssr使用root用户登录，运行以下命令：12345wget http://www.djangoz.com/linux_setup_ssr/ssrsudo mv ssr /usr/local/binsudo chmod 766 /usr/local/bin/ssrssr installssr config ssr的配置就不说明了，很简单的","link":"","tags":[{"name":"科学上网","slug":"科学上网","permalink":"http://www.djangoz.com/tags/科学上网/"}]},{"title":"求二叉树的最大深度和最小深度","date":"2017-08-14T16:00:00.000Z","path":"2017/08/15/Depth-of-Binary-tree/","text":"运用递归的思想实现起来简单很多。 二叉树的定义123456struct TreeNode&#123; int val; TreeNode *left,*right; TreeNode()&#123;&#125; TreeNode(int _val):val(_val),left(NULL),right(NULL)&#123;&#125;&#125;; 具体实现二叉树就不写了。 求二叉树的最大深度123456int maxDepth(TreeNode* root) &#123; if(!root)return 0; if(!root-&gt;left) return 1+maxDepth(root-&gt;right); if(!root-&gt;right) return 1+maxDepth(root-&gt;left); return 1+max(maxDepth(root-&gt;left),maxDepth(root-&gt;right));&#125; 求二叉树的最小深度123456int minDepth(TreeNode* root) &#123; if(!root)return 0; if(!root-&gt;left) return 1+minDepth(root-&gt;right); if(!root-&gt;right) return 1+minDepth(root-&gt;left); return 1+min(minDepth(root-&gt;left),minDepth(root-&gt;right));&#125;","link":"","tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://www.djangoz.com/tags/算法与数据结构/"}]},{"title":"先随便写写","date":"2017-08-11T16:00:00.000Z","path":"2017/08/12/wirte-something/","text":"今天终于学会在静态网站上安装插件了(其实也不算，是直接用的别人的主题)，原来也不难，昨天弄了老半天都没弄出来 还是写一写方法吧 (⊙o⊙)…还是以后在写吧，现在还不会用markdown写文档 初学者什么都不会~~o(&gt;_&lt;)o ~~ 还是直接贴我参考的地方吧在GitHub页面上使用Jekyll插件 把主题作者的github项目主页贴一下，表示感谢","link":"","tags":[{"name":"闲言碎语","slug":"闲言碎语","permalink":"http://www.djangoz.com/tags/闲言碎语/"}]},{"title":"创建博客成功","date":"2017-08-10T16:00:00.000Z","path":"2017/08/11/first-time/","text":"创建时间2017-08-11 23:17:37弄了一天终于弄成个样子了，准备装插件，但是一直没有成功更新时间2017-08-12 00:04:57","link":"","tags":[{"name":"闲言碎语","slug":"闲言碎语","permalink":"http://www.djangoz.com/tags/闲言碎语/"}]}]